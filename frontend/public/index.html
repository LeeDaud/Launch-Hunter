<!doctype html>
<html lang="zh-CN">
    <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0b1220" />
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Virtuals Sniping Decision Console</title>
    <style>
      :root {
        --bg: #070f1a;
        --card: #101e31;
        --card2: #15293f;
        --text: #e6f0ff;
        --muted: #8ea5bf;
        --accent: #65c2ff;
        --ok: #4ed78d;
        --warn: #f0c156;
        --wait: #7d8b9a;
        --danger: #ff5e78;
        --font-sans: "IBM Plex Sans", "Noto Sans SC", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Segoe UI", sans-serif;
        --font-mono: "JetBrains Mono", "Cascadia Mono", "SFMono-Regular", "Consolas", "Liberation Mono", monospace;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        color: var(--text);
        font-family: var(--font-sans);
        letter-spacing: .01em;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        background:
          radial-gradient(1200px 500px at 12% -18%, #1a3d60 0%, #0d1a2a 45%, var(--bg) 100%),
          linear-gradient(180deg, rgba(10,16,26,.96), rgba(7,12,19,.98));
        min-height: 100vh;
      }
      .wrap { max-width: 1680px; margin: 0 auto; padding: 18px; }
      .card {
        position: relative;
        overflow: hidden;
        background: linear-gradient(180deg, rgba(20,40,62,.9), rgba(14,28,45,.92));
        border: 1px solid rgba(124, 162, 198, .18);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 14px 34px rgba(0,0,0,.26);
      }
      .card::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(140deg, rgba(111, 183, 245, .06), transparent 35%, transparent 65%, rgba(111, 183, 245, .04));
      }
      .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .topline {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 8px;
      }
      .lang-switch {
        display: inline-flex;
        gap: 4px;
        padding: 3px;
        border-radius: 999px;
        background: rgba(19, 38, 60, .85);
        outline: 1px solid rgba(123, 164, 205, .25);
      }
      .lang-switch .lang-btn {
        border: none;
        border-radius: 999px;
        min-width: 42px;
        height: 28px;
        padding: 0 10px;
        background: transparent;
        color: #b7d3ea;
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
      }
      .lang-switch .lang-btn.active {
        background: rgba(101,194,255,.22);
        color: #e8f4ff;
      }
      .input {
        background: #0b1523;
        border: none;
        border-radius: 8px;
        color: var(--text);
        padding: 10px 12px;
        outline: 1px solid rgba(123, 164, 205, .2);
        font-family: inherit;
      }
      .mono { font-family: var(--font-mono); letter-spacing: 0; }
      .grow { flex: 1; min-width: 280px; }
      .btn {
        border: none;
        border-radius: 8px;
        padding: 10px 12px;
        background: #1f4163;
        color: var(--text);
        cursor: pointer;
      }
      .btn.active { outline: 2px solid rgba(101,194,255,.8); }
      .btn.btn-light {
        background: rgba(96, 132, 170, .26);
        color: #d8e9f8;
        padding: 10px 10px;
      }
      .btn.btn-light:hover { background: rgba(96, 132, 170, .4); }
      .launch-control {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        min-height: 40px;
      }
      .launch-label {
        color: #9bb7d0;
        font-size: 12px;
        white-space: nowrap;
      }
      .launch-display {
        min-width: 182px;
        text-align: left;
        background: rgba(10, 22, 36, .9);
        outline: 1px solid rgba(123, 164, 205, .2);
      }
      .launch-fallback {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
      }
      .launch-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 40;
      }
      .launch-modal.hidden { display: none; }
      .launch-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(2, 7, 13, .58);
        backdrop-filter: blur(3px);
      }
      .launch-sheet {
        position: relative;
        width: min(760px, calc(100vw - 24px));
        border-radius: 18px;
        padding: 14px;
        background: linear-gradient(180deg, rgba(21, 37, 58, .82), rgba(14, 26, 44, .86));
        border: 1px solid rgba(158, 197, 233, .2);
        box-shadow: 0 30px 80px rgba(0, 0, 0, .45);
      }
      .launch-sheet-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .launch-sheet-title { font-size: 14px; color: #d8ecff; }
      .launch-sheet-close {
        border: none;
        border-radius: 10px;
        width: 32px;
        height: 32px;
        color: #d4e6f9;
        background: rgba(117, 152, 186, .16);
        cursor: pointer;
        font-family: inherit;
      }
      .launch-sheet-value {
        margin-top: 8px;
        color: #aad0ee;
        font-size: 13px;
      }
      .wheel-stage {
        --wheel-item-h: 40px;
        position: relative;
        margin-top: 10px;
        height: calc(var(--wheel-item-h) * 3);
        display: grid;
        grid-template-columns: 1.4fr 1fr 1fr;
        gap: 8px;
      }
      .wheel-focus {
        position: absolute;
        left: 0;
        right: 0;
        top: var(--wheel-item-h);
        height: var(--wheel-item-h);
        border-radius: 10px;
        border: 1px solid rgba(103, 169, 224, .4);
        background: linear-gradient(180deg, rgba(77, 136, 186, .16), rgba(77, 136, 186, .1));
        pointer-events: none;
      }
      .wheel-col {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        background: rgba(10, 20, 33, .65);
      }
      .wheel-col-controls {
        margin-top: 6px;
        display: flex;
        gap: 6px;
        justify-content: center;
      }
      .wheel-step-btn {
        border: 1px solid rgba(127, 170, 212, .28);
        background: rgba(16, 31, 48, .9);
        color: #d2e7fa;
        border-radius: 8px;
        padding: 2px 8px;
        font-size: 12px;
        line-height: 1.2;
        cursor: pointer;
      }
      .wheel-col-title {
        position: absolute;
        top: 4px;
        left: 8px;
        z-index: 2;
        font-size: 11px;
        color: #8eaaca;
      }
      .wheel-list {
        height: calc(var(--wheel-item-h) * 3);
        overflow-y: auto;
        scroll-snap-type: y proximity;
        scrollbar-width: none;
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
      }
      .wheel-list::-webkit-scrollbar { display: none; }
      .wheel-track { padding: var(--wheel-item-h) 0; }
      .wheel-item {
        height: var(--wheel-item-h);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #9db7d0;
        scroll-snap-align: center;
        scroll-snap-stop: normal;
        user-select: none;
      }
      .wheel-item.active {
        color: #eaf5ff;
        font-weight: 700;
      }
      .launch-sheet-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .btn.btn-subtle {
        background: rgba(96, 132, 170, .2);
        color: #c6ddf2;
      }
      .status {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 10px;
      }
      .pill {
        background: rgba(101,194,255,.11);
        color: #c8e8ff;
        border-radius: 10px;
        padding: 9px 11px;
        border: 1px solid rgba(127, 170, 212, .15);
      }
      .hint {
        margin-top: 8px;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        color: #c7d9eb;
        background: rgba(120, 151, 182, .12);
      }
      .hint.ok { color: #bdeecf; background: rgba(78, 215, 141, .14); }
      .hint.warn { color: #ffd89d; background: rgba(240, 193, 86, .14); }
      .hint.err { color: #ffb5c2; background: rgba(255, 94, 120, .14); }
      .wallet-cfg {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1.1fr auto;
        gap: 8px;
      }
      .wallet-textarea {
        min-height: 86px;
        resize: vertical;
        width: 100%;
      }
      .wallet-actions {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .wallet-tags {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .wallet-tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(101,194,255,.14);
        color: #d5ecff;
        font-size: 12px;
      }
      .wallet-tag button {
        border: none;
        background: transparent;
        color: #b6d6ef;
        cursor: pointer;
        font-size: 12px;
      }
      .wallet-label-input {
        width: 120px;
        border: none;
        border-radius: 6px;
        padding: 2px 6px;
        background: rgba(15, 29, 45, .9);
        color: #d8ebfb;
        outline: 1px solid rgba(123, 164, 205, .22);
        font-size: 12px;
      }
      .wallet-name {
        color: #d8ecff;
        margin-right: 6px;
      }
      .mywallet-card { margin-top: 10px; }
      .copy-btn {
        border: none;
        border-radius: 6px;
        padding: 2px 6px;
        background: rgba(100,136,169,.2);
        color: #c8e0f2;
        cursor: pointer;
      }
      .status-chip {
        display: inline-flex;
        align-items: center;
        margin-left: 8px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 11px;
        background: rgba(120,151,182,.16);
        color: #bcd5ea;
      }
      .status-chip.queued { background: rgba(240,193,86,.16); color: #ffd99f; }
      .status-chip.running { background: rgba(101,194,255,.16); color: #b8e4ff; }
      .status-chip.done { background: rgba(78,215,141,.16); color: #bcf1d2; }
      .status-chip.error { background: rgba(255,94,120,.16); color: #ffc3cf; }

      .hero {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(3, minmax(280px, 1fr));
        gap: 12px;
      }

      .kpis {
        display: grid;
        grid-template-columns: repeat(2, minmax(120px, 1fr));
        gap: 8px;
      }
      .kpi { background: rgba(10,22,36,.74); border-radius: 10px; padding: 10px; border: 1px solid rgba(127,170,212,.14); }
      .kpi .k { font-size: 12px; color: var(--muted); }
      .kpi .v { margin-top: 3px; font-size: 18px; font-weight: 700; }

      .rule-title { font-size: 12px; color: #bbddff; }
      .rule-state { margin-top: 6px; font-size: 24px; font-weight: 800; letter-spacing: .4px; }
      .s-wait { color: var(--wait); }
      .s-first { color: var(--warn); }
      .s-second { color: var(--ok); }
      .s-trigger { color: var(--danger); }
      .blink { animation: blink 1s infinite; }
      @keyframes blink { 0% { opacity:.4; } 50% { opacity:1; } 100% { opacity:.4; } }

      .bars { margin-top: 8px; height: 72px; display: grid; grid-template-columns: repeat(10,1fr); gap: 6px; align-items: end; }
      .bar { background: linear-gradient(180deg, #86d4ff, #3f7fb8); border-radius: 4px 4px 2px 2px; min-height: 4px; }

      .curve-wrap { height: 240px; margin-top: 8px; background: rgba(10,22,36,.74); border-radius: 10px; padding: 8px; border: 1px solid rgba(127,170,212,.14); }
      .curve-legend { display: flex; gap: 16px; font-size: 12px; color: var(--muted); }
      .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }

      .monitor-stack { margin-top: 12px; display: flex; flex-direction: column; gap: 12px; width: 100%; }
      .monitor-row { width: 100%; min-width: 0; }
      .monitor-row.card { display: block; }
      .table-wrap {
        max-height: 52vh;
        overflow: auto;
        border-radius: 10px;
        border: 1px solid rgba(127,170,212,.14);
        background: rgba(8,18,30,.52);
      }
      table { width: 100%; border-collapse: collapse; font-size: 12px; }
      th, td { padding: 8px 6px; text-align: left; }
      th { color: #abd3ef; }
      tbody tr { border-top: 1px solid rgba(130,160,190,.14); }
      .good { color: var(--ok); }
      .bad { color: #ff8da0; }
      .proto-tabs { display: flex; gap: 8px; margin-top: 8px; margin-bottom: 8px; flex-wrap: wrap; }
      .proto-tab-btn {
        border: 1px solid rgba(127,170,212,.2);
        background: rgba(20,37,58,.72);
        color: #c7e4fb;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .proto-tab-btn.active {
        background: rgba(101,194,255,.22);
        color: #e9f6ff;
        border-color: rgba(101,194,255,.5);
      }
      .proto-pane.hidden { display: none; }
      .empty-text { color: #9fc2df; font-size: 12px; padding: 10px 4px; }
      .protocol-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 10px; }

      @media (max-width: 1120px) {
        .hero { grid-template-columns: 1fr; }
      }
      @media (max-width: 900px) {
        .status { grid-template-columns: 1fr; }
        .wrap { padding: 12px; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <div class="topline">
          <div class="lang-switch" role="group" aria-label="language switch">
            <button id="langZhBtn" class="lang-btn active" type="button">中</button>
            <button id="langEnBtn" class="lang-btn" type="button">EN</button>
          </div>
        </div>
        <div class="row">
          <input id="tokenInput" class="input grow" placeholder="Token CA (0x...)" data-i18n-ph="ph_token" />
          <div class="launch-control">
            <span class="launch-label" data-i18n="launch_label">Launch Start Time</span>
            <button id="launchDisplayBtn" class="btn launch-display mono" type="button" aria-haspopup="dialog" aria-controls="launchModal">-</button>
            <button id="setNowBtn" class="btn btn-light" type="button" data-i18n="set_now">Set Now</button>
            <input type="datetime-local" id="launchStart" class="input mono launch-fallback" aria-label="Launch Start Time fallback" data-i18n-aria="launch_fallback_aria" />
          </div>
          <input id="walletInput" class="input" style="width:220px" placeholder="My Wallet (0x...)" data-i18n-ph="ph_wallet" />
          <input id="sellTaxInput" class="input" style="width:110px" placeholder="SellTax %" value="1" data-i18n-ph="ph_sell_tax" />
          <button id="startBtn" class="btn" data-i18n="start_track">开始追踪</button>
          <button id="stopBtn" class="btn" data-i18n="stop_track">停止</button>
          <button id="modeToken" class="btn active" data-mode="token_received" data-i18n="mode_token">Token</button>
          <button id="modeVirtual" class="btn" data-mode="virtual_spent" data-i18n="mode_virtual">Virtual</button>
        </div>
        <div class="wallet-cfg">
          <textarea id="myWalletsInput" class="input wallet-textarea" placeholder="Add wallet addresses (one per line)" data-i18n-ph="ph_wallets"></textarea>
          <div class="wallet-actions">
            <input id="myWalletFromBlockInput" class="input" style="width:170px" placeholder="My FromBlock" data-i18n-ph="ph_from_block" />
            <input id="tokenStartBlockInput" class="input" style="width:170px" placeholder="Token StartBlock" />
            <input id="spotPairInput" class="input mono" style="width:260px" placeholder="Spot Pair (0x...)" />
            <button id="myWalletApplyBtn" class="btn btn-light" type="button" data-i18n="add_wallets">Add Wallets</button>
            <button id="myWalletClearBtn" class="btn btn-light" type="button" data-i18n="clear_wallets">Clear Wallets</button>
          </div>
        </div>
        <div id="myWalletTags" class="wallet-tags"></div>
        <div class="mywallet-card">
          <div style="font-size:13px;color:#c3e5ff;margin-bottom:6px;">
            <span data-i18n="my_wallets">My Wallets</span>
            <span id="myWalletStatusChip" class="status-chip">idle</span>
          </div>
          <div class="table-wrap" style="max-height:none;">
            <table>
              <thead>
                <tr>
                  <th data-i18n="th_scope">Scope</th>
                  <th data-i18n="th_balance">Balance</th>
                  <th data-i18n="th_spent_v">Spent V</th>
                  <th data-i18n="th_recv_t">Recv T</th>
                  <th data-i18n="th_cost">Cost</th>
                  <th data-i18n="th_eff_cost">Eff Cost</th>
                  <th data-i18n="th_be_mcap">BE MCAP</th>
                  <th data-i18n="th_last_active">Last Active</th>
                </tr>
              </thead>
              <tbody id="myWalletTotalBody"></tbody>
            </table>
          </div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th data-i18n="th_address">Address</th>
                  <th data-i18n="th_balance">Balance</th>
                  <th data-i18n="th_spent_v">Spent V</th>
                  <th data-i18n="th_recv_t">Recv T</th>
                  <th data-i18n="th_cost">Cost</th>
                  <th data-i18n="th_eff_cost">Eff Cost</th>
                  <th data-i18n="th_be_mcap">BE MCAP</th>
                  <th data-i18n="th_last_active">Last Active</th>
                </tr>
              </thead>
              <tbody id="myWalletBody"></tbody>
            </table>
          </div>
        </div>
        <div class="status">
          <div id="tokenPill" class="pill mono">Token: -</div>
          <div id="statusPill" class="pill mono">Status: stopped | Block: -</div>
          <div id="transferPill" class="pill mono">Transfers: -</div>
        </div>
        <div id="actionHint" class="hint" data-i18n="hint_ready">Ready.</div>
      </div>

      <div class="hero">
        <div class="card">
          <div class="rule-title" data-i18n="rule_title">规则状态</div>
          <div id="ruleState" class="rule-state s-wait">等待中</div>
          <div id="ruleDesc" style="font-size:12px;color:#9fb8ce;margin-top:5px;">等待连续两分钟突破 3000 / 6000</div>
          <div id="taxNow" style="margin-top:8px;font-size:13px;color:#c7e6ff;">当前买入税率: 1%</div>
          <div id="pairNow" class="mono" style="margin-top:4px;font-size:12px;color:#aac7dd;">Pair: -</div>
          <div class="bars" id="bars"></div>
        </div>

        <div class="card">
          <div class="curve-legend">
            <span><i class="dot" style="background:#67c4ff"></i>EMV</span>
            <span><i class="dot" style="background:#f8b24f"></i>RMV</span>
          </div>
          <div class="curve-wrap">
            <svg id="curveSvg" viewBox="0 0 1000 240" width="100%" height="100%"></svg>
          </div>
        </div>

        <div class="card">
          <div class="kpis">
            <div class="kpi"><div class="k" data-i18n="kpi_1m">1m Taxed Vol</div><div id="kpi1" class="v">0</div></div>
            <div class="kpi"><div class="k" data-i18n="kpi_2m">2m Seq</div><div id="kpi2" class="v">0</div></div>
            <div class="kpi"><div class="k" data-i18n="kpi_5m">5m Taxed Vol</div><div id="kpi5" class="v">0</div></div>
            <div class="kpi"><div class="k" data-i18n="kpi_cd">Cooldown</div><div id="kpiCd" class="v">Ready</div></div>
            <div class="kpi"><div class="k" data-i18n="kpi_rmv">My RMV</div><div id="kpiRmv" class="v">0</div></div>
            <div class="kpi"><div class="k" data-i18n="kpi_cost">My Cost</div><div id="kpiCost" class="v">0</div></div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <div style="font-size:13px;color:#c3e5ff;">Realtime Price & Recent Trades</div>
          <div class="row">
            <button id="strictChainModeBtn" class="btn btn-light" type="button">Strict Chain: ON</button>
            <input id="pricePrecisionInput" class="input mono" style="width:110px" placeholder="Price Dec" value="8" />
            <input id="mcapPrecisionInput" class="input mono" style="width:110px" placeholder="MCAP Dec" value="2" />
            <div id="spotMetaText" class="mono" style="font-size:12px;color:#9fc2df;">-</div>
          </div>
        </div>
        <div class="status" style="margin-top:0;">
          <div id="spotPricePill" class="pill mono">Spot Price /virtual: -</div>
          <div id="spotMcapPill" class="pill mono">Spot MCAP /virtual: -</div>
          <div id="spotPriceUsdPill" class="pill mono">Spot Price /usd: -</div>
          <div id="spotMcapUsdPill" class="pill mono">Spot MCAP /usd: -</div>
        </div>
        <div class="table-wrap" style="max-height:34vh; margin-top:8px;">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Block/Log</th>
                <th>Side</th>
                <th>From</th>
                <th>To</th>
                <th>Amount T</th>
                <th>Amount Raw</th>
                <th>Price</th>
                <th>Hash</th>
              </tr>
            </thead>
            <tbody id="recentTradeBody"></tbody>
          </table>
        </div>
      </div>

      <div id="monitorStack" class="monitor-stack">
        <div class="card monitor-row">
          <div style="font-size:13px;color:#c3e5ff;margin-bottom:6px;" data-i18n="holders_title">Holders</div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th data-i18n="th_address">Address</th>
                  <th data-i18n="th_balance">Balance</th>
                  <th data-i18n="th_cum_in">Cum In</th>
                  <th data-i18n="th_cum_out">Cum Out</th>
                  <th data-i18n="th_share">Share%</th>
                  <th>Δ5m</th>
                  <th data-i18n="th_cost">Cost</th>
                  <th data-i18n="th_be_mcap">BE MCAP</th>
                </tr>
              </thead>
              <tbody id="holderBody"></tbody>
            </table>
          </div>
        </div>

        <div class="card monitor-row">
          <div style="font-size:13px;color:#c3e5ff;margin-bottom:6px;">Special Protocol Flows</div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>Label</th>
                  <th>Category</th>
                  <th>5m V</th>
                  <th>1h V</th>
                  <th>Cum V</th>
                  <th>5m T</th>
                  <th>Cum T</th>
                </tr>
              </thead>
              <tbody id="specialBody"></tbody>
            </table>
          </div>
          <div id="specialFlowsEmpty" class="empty-text hidden">No special flows detected yet</div>
        </div>

        <div class="card monitor-row">
          <div style="font-size:13px;color:#c3e5ff;margin-bottom:6px;">Protocol Activity</div>
          <div class="protocol-summary-grid">
            <div id="protocol1mPill" class="pill mono">Net 1m: -</div>
            <div id="protocol5mPill" class="pill mono">Net 5m: -</div>
            <div id="protocolExecPill" class="pill mono">Executor 5m: -</div>
            <div id="sellWallBalancePill" class="pill mono">Sell Wall Balance: -</div>
            <div id="launchPoolBalancePill" class="pill mono">LaunchPool Balance: -</div>
            <div id="protocolPotentialText" class="pill mono">Potential: -</div>
          </div>
          <div id="protocolAlertText" class="mono" style="margin-top:8px;font-size:12px;color:#9fc2df;">Alert: -</div>
          <div class="table-wrap" style="margin-top:8px;">
            <table>
              <thead>
                <tr>
                  <th>Address</th>
                  <th>Type</th>
                  <th>Net 1m V</th>
                  <th>Net 5m V</th>
                  <th>Net 5m T</th>
                  <th>Interactions 5m</th>
                </tr>
              </thead>
              <tbody id="protocolBody"></tbody>
            </table>
          </div>
          <div id="protocolAddressesEmpty" class="empty-text hidden">No protocol addresses yet</div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div style="font-size:13px;color:#c3e5ff;margin-bottom:6px;">Explorer TokenTx</div>
        <div class="row" style="margin-bottom:8px;">
          <input id="explorerAddressInput" class="input mono grow" placeholder="address (wallet or contract, required)" />
          <input id="explorerContractInput" class="input mono grow" placeholder="contractaddress (token, optional)" />
          <input id="explorerChainIdInput" class="input mono" style="width:100px" value="8453" placeholder="chainid" />
          <select id="explorerSortInput" class="input" style="width:100px">
            <option value="desc" selected>desc</option>
            <option value="asc">asc</option>
          </select>
        </div>
        <div class="row" style="margin-bottom:8px;">
          <input id="explorerStartBlockInput" class="input mono" style="width:140px" value="0" placeholder="startblock" />
          <input id="explorerEndBlockInput" class="input mono" style="width:140px" value="99999999" placeholder="endblock" />
          <input id="explorerPageInput" class="input mono" style="width:100px" value="1" placeholder="page" />
          <input id="explorerOffsetInput" class="input mono" style="width:100px" value="50" placeholder="offset" />
          <button id="explorerQueryBtn" class="btn" type="button">Query</button>
          <button id="explorerResetBtn" class="btn btn-light" type="button">Reset</button>
          <span id="explorerStatusText" class="mono" style="font-size:12px;color:#9fc2df;"></span>
        </div>
        <div class="table-wrap" style="max-height:34vh;">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Hash</th>
                <th>Token</th>
                <th>From</th>
                <th>To</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="explorerTxBody"></tbody>
          </table>
        </div>
      </div>

    </div>

    <div id="launchModal" class="launch-modal hidden" role="dialog" aria-modal="true" aria-labelledby="launchSheetTitle">
      <div id="launchBackdrop" class="launch-backdrop"></div>
      <div class="launch-sheet">
        <div class="launch-sheet-header">
          <div id="launchSheetTitle" class="launch-sheet-title" data-i18n="launch_modal_title">Select Launch Start Time</div>
          <button id="launchCloseBtn" class="launch-sheet-close" type="button" aria-label="Close" data-i18n-aria="close">X</button>
        </div>
        <div id="launchSheetValue" class="launch-sheet-value mono">-</div>
        <div class="wheel-stage">
          <div class="wheel-focus"></div>
          <div class="wheel-col">
            <div class="wheel-col-title" data-i18n="wheel_date">Date</div>
            <div id="wheelDate" class="wheel-list" role="listbox" aria-label="Date"></div>
            <div class="wheel-col-controls">
              <button class="wheel-step-btn" type="button" data-wheel-step="date:-1">-1</button>
              <button class="wheel-step-btn" type="button" data-wheel-step="date:1">+1</button>
            </div>
          </div>
          <div class="wheel-col">
            <div class="wheel-col-title" data-i18n="wheel_hour">Hour</div>
            <div id="wheelHour" class="wheel-list" role="listbox" aria-label="Hour"></div>
            <div class="wheel-col-controls">
              <button class="wheel-step-btn" type="button" data-wheel-step="hour:-1">-1</button>
              <button class="wheel-step-btn" type="button" data-wheel-step="hour:1">+1</button>
            </div>
          </div>
          <div class="wheel-col">
            <div class="wheel-col-title" data-i18n="wheel_minute">Minute</div>
            <div id="wheelMinute" class="wheel-list" role="listbox" aria-label="Minute"></div>
            <div class="wheel-col-controls">
              <button class="wheel-step-btn" type="button" data-wheel-step="minute:-1">-1</button>
              <button class="wheel-step-btn" type="button" data-wheel-step="minute:1">+1</button>
            </div>
          </div>
        </div>
        <div class="launch-sheet-actions">
          <button id="launchCancelBtn" class="btn btn-subtle" type="button" data-i18n="cancel">Cancel</button>
          <button id="launchConfirmBtn" class="btn" type="button" data-i18n="confirm">Confirm</button>
        </div>
      </div>
    </div>

    <script src="/runtime-config.js"></script>
    <script>
      const $ = (id) => document.getElementById(id);
      const tokenInput = $('tokenInput');
      const launchInput = $('launchStart');
      const walletInput = $('walletInput');
      const sellTaxInput = $('sellTaxInput');
      const launchDisplayBtn = $('launchDisplayBtn');
      const setNowBtn = $('setNowBtn');
      const startBtn = $('startBtn');
      const stopBtn = $('stopBtn');
      const actionHint = $('actionHint');
      const myWalletsInput = $('myWalletsInput');
      const myWalletFromBlockInput = $('myWalletFromBlockInput');
      const tokenStartBlockInput = $('tokenStartBlockInput');
      const spotPairInput = $('spotPairInput');
      const myWalletApplyBtn = $('myWalletApplyBtn');
      const myWalletClearBtn = $('myWalletClearBtn');
      const langZhBtn = $('langZhBtn');
      const langEnBtn = $('langEnBtn');
      const myWalletTags = $('myWalletTags');
      const myWalletTotalBody = $('myWalletTotalBody');
      const myWalletBody = $('myWalletBody');
      const myWalletStatusChip = $('myWalletStatusChip');
      const launchModal = $('launchModal');
      const launchBackdrop = $('launchBackdrop');
      const launchCloseBtn = $('launchCloseBtn');
      const launchCancelBtn = $('launchCancelBtn');
      const launchConfirmBtn = $('launchConfirmBtn');
      const launchSheetValue = $('launchSheetValue');
      const wheelDate = $('wheelDate');
      const wheelHour = $('wheelHour');
      const wheelMinute = $('wheelMinute');
      const tokenPill = $('tokenPill');
      const statusPill = $('statusPill');
      const transferPill = $('transferPill');
      const ruleState = $('ruleState');
      const ruleDesc = $('ruleDesc');
      const taxNow = $('taxNow');
      const pairNow = $('pairNow');
      const bars = $('bars');
      const curveSvg = $('curveSvg');
      const holderBody = $('holderBody');
      const specialBody = $('specialBody');
      const specialFlowsEmpty = $('specialFlowsEmpty');
      const protocol1mPill = $('protocol1mPill');
      const protocol5mPill = $('protocol5mPill');
      const protocolExecPill = $('protocolExecPill');
      const sellWallBalancePill = $('sellWallBalancePill');
      const launchPoolBalancePill = $('launchPoolBalancePill');
      const protocolAlertText = $('protocolAlertText');
      const protocolPotentialText = $('protocolPotentialText');
      const protocolBody = $('protocolBody');
      const protocolAddressesEmpty = $('protocolAddressesEmpty');
      const kpi1 = $('kpi1');
      const kpi2 = $('kpi2');
      const kpi5 = $('kpi5');
      const kpiCd = $('kpiCd');
      const kpiRmv = $('kpiRmv');
      const kpiCost = $('kpiCost');
      const strictChainModeBtn = $('strictChainModeBtn');
      const spotPricePill = $('spotPricePill');
      const spotMcapPill = $('spotMcapPill');
      const spotPriceUsdPill = $('spotPriceUsdPill');
      const spotMcapUsdPill = $('spotMcapUsdPill');
      const pricePrecisionInput = $('pricePrecisionInput');
      const mcapPrecisionInput = $('mcapPrecisionInput');
      const spotMetaText = $('spotMetaText');
      const recentTradeBody = $('recentTradeBody');
      const explorerAddressInput = $('explorerAddressInput');
      const explorerContractInput = $('explorerContractInput');
      const explorerChainIdInput = $('explorerChainIdInput');
      const explorerStartBlockInput = $('explorerStartBlockInput');
      const explorerEndBlockInput = $('explorerEndBlockInput');
      const explorerPageInput = $('explorerPageInput');
      const explorerOffsetInput = $('explorerOffsetInput');
      const explorerSortInput = $('explorerSortInput');
      const explorerQueryBtn = $('explorerQueryBtn');
      const explorerResetBtn = $('explorerResetBtn');
      const explorerStatusText = $('explorerStatusText');
      const explorerTxBody = $('explorerTxBody');

      let latest = null;
      let latestProtocol = null;
      let flashUntil = 0;
      const LAUNCH_START_KEY = 'launchStartTime';
      const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
      const WHEEL_ITEM_HEIGHT = 40;
      const WHEEL_SNAP_DELAY = 240;
      const pickerState = {
        dateOptions: [],
        hourOptions: Array.from({ length: 24 }, (_, i) => i),
        minuteOptions: Array.from({ length: 60 }, (_, i) => i),
        selectedDateIndex: 0,
        selectedHourIndex: 0,
        selectedMinuteIndex: 0,
      };
      const wheelTimers = {};
      const wheelLastTop = {};
      const LS_TOKEN_KEY = 'lastTrackedToken';
      const LS_WALLET_KEY = 'lastWalletAddress';
      const LS_MY_WALLETS_KEY = 'myWalletsList';
      const LS_MY_WALLETS_LABELS_KEY = 'myWalletsLabels';
      const LS_MY_FROM_BLOCK_KEY = 'myWalletFromBlock';
      const LS_TOKEN_START_BLOCK_KEY = 'tokenStartBlock';
      const LS_SPOT_PAIR_KEY = 'spotPairAddress';
      const LS_LANG_KEY = 'uiLang';
      const LS_EXPLORER_OPTS_KEY = 'explorerTokentxOptions';
      const LS_STRICT_CHAIN_MODE_KEY = 'strictChainMode';
      const LS_PRICE_PRECISION_KEY = 'pricePrecision';
      const LS_MCAP_PRECISION_KEY = 'mcapPrecision';
      let currentLang = localStorage.getItem(LS_LANG_KEY) || 'zh';
      const API_BASE = String(window.__API_BASE__ || '').trim().replace(/\/+$/, '');
      const apiUrl = (pathname) => {
        const p = String(pathname || '');
        if (/^https?:\/\//i.test(p)) return p;
        const normalized = p.startsWith('/') ? p : `/${p}`;
        return API_BASE ? `${API_BASE}${normalized}` : normalized;
      };
      let eventSource = null;
      let sseRetryTimer = null;
      let startBusy = false;
      let stopBusy = false;
      let myWallets = [];
      let walletLabels = {};
      let launchStartSec = 0;
      let strictChainMode = String(localStorage.getItem(LS_STRICT_CHAIN_MODE_KEY) ?? '1') !== '0';
      const EXPLORER_DEFAULTS = {
        chainid: '8453',
        startblock: '0',
        endblock: '99999999',
        page: '1',
        offset: '50',
        sort: 'desc',
      };
      const I18N = {
        zh: {
          ph_token: 'Token 合约地址 (0x...)',
          ph_wallet: '我的钱包 (0x...)',
          ph_sell_tax: '卖出税 %',
          ph_wallets: '添加钱包地址（每行一个）',
          ph_from_block: '我的回扫起始块',
          launch_label: '开盘时间',
          launch_fallback_aria: '开盘时间后备输入',
          set_now: '设为当前',
          start_track: '开始追踪',
          stop_track: '停止',
          mode_token: '口径 Token',
          mode_virtual: '口径 Virtual',
          add_wallets: '添加钱包',
          clear_wallets: '清空钱包',
          my_wallets: '我的钱包',
          th_scope: '范围',
          th_balance: '余额',
          th_spent_v: '累计花费V',
          th_recv_t: '累计到手T',
          th_cost: '成本',
          th_eff_cost: '有效成本',
          th_be_mcap: '回本市值',
          th_last_active: '最后活跃',
          th_address: '地址',
          th_cum_in: '累计流入',
          th_cum_out: '累计流出',
          th_share: '占比%',
          th_label: '标签',
          th_category: '分类',
          hint_ready: '就绪。',
          rule_title: '规则状态',
          kpi_1m: '1分钟税后量',
          kpi_2m: '2分钟序列',
          kpi_5m: '5分钟税后量',
          kpi_cd: '冷却',
          kpi_rmv: '我的RMV',
          kpi_cost: '我的成本',
          holders_title: '持仓榜',
          special_title: '协议特殊资金流',
          launch_modal_title: '选择开盘时间',
          wheel_date: '日期',
          wheel_hour: '小时',
          wheel_minute: '分钟',
          close: '关闭',
          cancel: '取消',
          confirm: '确认',
          status_running: '运行中',
          status_stopped: '已停止',
          status_disconnected: '已断开',
          status_line: '状态: {status} | 区块: {block}',
          token_line: '代币: {token}',
          transfers_waiting: '交易: 等待中...',
          transfers_none: '交易: 当前窗口无转账',
          transfers_need_virtual: '交易: 请配置 VIRTUAL_CA / VIRTUAL_TOKEN_ADDRESS',
          transfers_logs: '交易: logs {logs} | tx {tx}',
          transfers_disconnected: '交易: 连接断开',
          pair: '序列',
          tax_now: '当前买入税率: {tax}%',
          cd_ready: '可触发',
          rule_wait: '等待',
          rule_wait_desc: '等待连续两分钟突破 3000 / 6000',
          rule_first: '第一阈值突破',
          rule_first_desc: '等待第二分钟确认',
          rule_second: '第二阈值确认',
          rule_second_desc: '连续两分钟突破成立',
          rule_trigger: '入场触发',
          rule_trigger_desc: '规则已触发，进入冷却期',
          wallet_state_running: '回扫进行中',
          wallet_state_queued: '回扫排队中',
          wallet_state_done: '回扫完成',
          wallet_state_error: '回扫失败',
          wallet_state_idle: '空闲',
          wallet_total: '总计',
          wallet_copy: '复制',
          wallet_name_placeholder: '备注',
          wallet_copy_ok: '已复制 {addr}',
          set_now_ok: '已设置为当前时间。',
          runtime_updated: '运行参数已更新。',
          wallets_updated: '我的钱包已更新 ({count})',
          wallets_update_failed: '钱包更新失败: {msg}',
          wallets_invalid: '未识别有效钱包地址，请每行输入一个地址。',
          wallets_added: '新增 {count} 个钱包，总计 {total}。',
          wallets_exists: '地址已存在，未新增。',
          start_invalid_token: 'Token 地址格式无效，请输入 0x 开头的 42 位地址。',
          start_busy: '启动中...',
          start_scanning: '正在启动追踪任务并回扫历史...',
          start_ok: '追踪已启动。',
          start_abort_running: '启动请求超时，但任务已在后台运行。',
          start_abort_failed: '启动超时，任务可能未成功启动。',
          start_abort_check_failed: '启动超时，且状态回查失败。',
          start_failed: '启动失败: {msg}',
          stop_busy: '停止中...',
          stop_wait: '正在停止追踪任务...',
          stop_ok: '追踪已停止。',
          stop_abort_done: '停止请求超时，但任务已停止。',
          stop_abort_running: '停止超时，任务可能仍在运行。',
          stop_abort_check_failed: '停止超时，且状态回查失败。',
          stop_failed: '停止失败: {msg}',
          sse_connected: '实时流已连接。',
          sse_disconnected: '实时流断开，正在重连...',
          init_status_failed: '获取初始状态失败，请检查后端服务。',
        },
        en: {
          ph_token: 'Token CA (0x...)',
          ph_wallet: 'My Wallet (0x...)',
          ph_sell_tax: 'SellTax %',
          ph_wallets: 'Add wallet addresses (one per line)',
          ph_from_block: 'My FromBlock',
          launch_label: 'Launch Start Time',
          launch_fallback_aria: 'Launch start time fallback',
          set_now: 'Set Now',
          start_track: 'Start',
          stop_track: 'Stop',
          mode_token: 'Metric Token',
          mode_virtual: 'Metric Virtual',
          add_wallets: 'Add Wallets',
          clear_wallets: 'Clear Wallets',
          my_wallets: 'My Wallets',
          th_scope: 'Scope',
          th_balance: 'Balance',
          th_spent_v: 'Spent V',
          th_recv_t: 'Recv T',
          th_cost: 'Cost',
          th_eff_cost: 'Eff Cost',
          th_be_mcap: 'BE MCAP',
          th_last_active: 'Last Active',
          th_address: 'Address',
          th_cum_in: 'Cum In',
          th_cum_out: 'Cum Out',
          th_share: 'Share%',
          th_label: 'Label',
          th_category: 'Category',
          hint_ready: 'Ready.',
          rule_title: 'Rule State',
          kpi_1m: '1m Taxed Vol',
          kpi_2m: '2m Seq',
          kpi_5m: '5m Taxed Vol',
          kpi_cd: 'Cooldown',
          kpi_rmv: 'My RMV',
          kpi_cost: 'My Cost',
          holders_title: 'Holders',
          special_title: 'Special Protocol Flows',
          launch_modal_title: 'Select Launch Start Time',
          wheel_date: 'Date',
          wheel_hour: 'Hour',
          wheel_minute: 'Minute',
          close: 'Close',
          cancel: 'Cancel',
          confirm: 'Confirm',
          status_running: 'running',
          status_stopped: 'stopped',
          status_disconnected: 'disconnected',
          status_line: 'Status: {status} | Block: {block}',
          token_line: 'Token: {token}',
          transfers_waiting: 'Transfers: waiting...',
          transfers_none: 'Transfers: no transfers in window',
          transfers_need_virtual: 'Transfers: set VIRTUAL_CA / VIRTUAL_TOKEN_ADDRESS',
          transfers_logs: 'Transfers: logs {logs} | tx {tx}',
          transfers_disconnected: 'Transfers: disconnected',
          pair: 'Pair',
          tax_now: 'Buy Tax Now: {tax}%',
          cd_ready: 'Ready',
          rule_wait: 'Waiting',
          rule_wait_desc: 'Waiting for 3000 / 6000 two-minute breakout',
          rule_first: 'First Threshold',
          rule_first_desc: 'Waiting second-minute confirmation',
          rule_second: 'Second Threshold',
          rule_second_desc: 'Two-minute breakout confirmed',
          rule_trigger: 'Signal Triggered',
          rule_trigger_desc: 'Rule triggered, cooldown started',
          wallet_state_running: 'backfill running',
          wallet_state_queued: 'backfill queued',
          wallet_state_done: 'backfill done',
          wallet_state_error: 'backfill error',
          wallet_state_idle: 'idle',
          wallet_total: 'Total',
          wallet_copy: 'Copy',
          wallet_name_placeholder: 'Name',
          wallet_copy_ok: 'Copied {addr}',
          set_now_ok: 'Set to current time.',
          runtime_updated: 'Runtime settings updated.',
          wallets_updated: 'My Wallets updated ({count})',
          wallets_update_failed: 'Wallet update failed: {msg}',
          wallets_invalid: 'No valid wallet address found. Please input one address per line.',
          wallets_added: 'Added {count} wallet(s). Total {total}.',
          wallets_exists: 'All addresses already exist.',
          start_invalid_token: 'Invalid token address. Please input 42-char 0x address.',
          start_busy: 'Starting...',
          start_scanning: 'Starting tracker and backfilling history...',
          start_ok: 'Tracking started.',
          start_abort_running: 'Start timed out, but task is running in background.',
          start_abort_failed: 'Start timed out. Task may not have started.',
          start_abort_check_failed: 'Start timed out and status check failed.',
          start_failed: 'Start failed: {msg}',
          stop_busy: 'Stopping...',
          stop_wait: 'Stopping tracker...',
          stop_ok: 'Tracking stopped.',
          stop_abort_done: 'Stop timed out, but task has stopped.',
          stop_abort_running: 'Stop timed out, task may still be running.',
          stop_abort_check_failed: 'Stop timed out and status check failed.',
          stop_failed: 'Stop failed: {msg}',
          sse_connected: 'Realtime stream connected.',
          sse_disconnected: 'Realtime stream disconnected, reconnecting...',
          init_status_failed: 'Failed to load initial status. Check backend.',
        },
      };

      function t(key, vars = {}) {
        const langPack = I18N[currentLang] || I18N.zh;
        const fallbackPack = I18N.zh;
        let out = langPack[key] ?? fallbackPack[key] ?? key;
        for (const [k, v] of Object.entries(vars || {})) {
          out = out.replaceAll(`{${k}}`, String(v));
        }
        return out;
      }

      function applyI18nStatic() {
        document.querySelectorAll('[data-i18n]').forEach((el) => {
          const key = el.getAttribute('data-i18n');
          if (key) el.textContent = t(key);
        });
        document.querySelectorAll('[data-i18n-ph]').forEach((el) => {
          const key = el.getAttribute('data-i18n-ph');
          if (key) el.setAttribute('placeholder', t(key));
        });
        document.querySelectorAll('[data-i18n-aria]').forEach((el) => {
          const key = el.getAttribute('data-i18n-aria');
          if (key) el.setAttribute('aria-label', t(key));
        });
      }

      function setLanguage(lang) {
        currentLang = lang === 'en' ? 'en' : 'zh';
        localStorage.setItem(LS_LANG_KEY, currentLang);
        if (langZhBtn) langZhBtn.classList.toggle('active', currentLang === 'zh');
        if (langEnBtn) langEnBtn.classList.toggle('active', currentLang === 'en');
        document.documentElement.setAttribute('lang', currentLang === 'zh' ? 'zh-CN' : 'en');
        applyI18nStatic();
        renderMyWalletTags();
        if (latest) {
          renderSnapshot(latest);
        } else {
          tokenPill.textContent = t('token_line', { token: '-' });
          statusPill.textContent = t('status_line', { status: t('status_stopped'), block: '-' });
        }
      }

      function toLocalDatetimeValue(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        const hh = String(date.getHours()).padStart(2, '0');
        const mm = String(date.getMinutes()).padStart(2, '0');
        return `${y}-${m}-${d}T${hh}:${mm}`;
      }

      function formatLocalDisplayFromSeconds(sec) {
        if (!Number.isFinite(sec) || sec <= 0) return 'Auto';
        const d = new Date(sec * 1000);
        const y = d.getFullYear();
        const mo = String(d.getMonth() + 1).padStart(2, '0');
        const da = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${y}-${mo}-${da} ${hh}:${mm}`;
      }

      function parseLaunchStartSeconds() {
        if (Number.isFinite(launchStartSec) && launchStartSec > 0) return launchStartSec;
        if (!launchInput.value) return 0;
        const ms = new Date(launchInput.value).getTime();
        if (!Number.isFinite(ms)) return 0;
        launchStartSec = Math.floor(ms / 1000);
        return launchStartSec;
      }

      function setLaunchInputBySeconds(sec) {
        if (!Number.isFinite(sec) || sec <= 0) {
          launchStartSec = 0;
          launchInput.value = '';
          launchDisplayBtn.textContent = formatLocalDisplayFromSeconds(0);
          return;
        }
        launchStartSec = Math.floor(sec);
        launchInput.value = toLocalDatetimeValue(new Date(launchStartSec * 1000));
        launchDisplayBtn.textContent = formatLocalDisplayFromSeconds(sec);
      }

      function computeBuyTaxPctFromStart(startSec) {
        if (!Number.isFinite(startSec) || startSec <= 0) return 1;
        const nowSec = Math.floor(Date.now() / 1000);
        const deltaSec = Math.max(0, nowSec - startSec);
        const minutes = Math.floor(deltaSec / 60);
        return clamp(99 - minutes, 1, 99);
      }

      async function applyLaunchStartChange(pushRuntime = true) {
        const startSec = parseLaunchStartSeconds();
        localStorage.setItem(LAUNCH_START_KEY, String(startSec));
        launchDisplayBtn.textContent = formatLocalDisplayFromSeconds(startSec);

        if (latest) {
          latest.tax = latest.tax || {};
          latest.tax.buy_tax_pct = computeBuyTaxPctFromStart(startSec);
          latest.tax.launch_start_time = startSec;
          renderSnapshot(latest);
        }

        if (!pushRuntime) return;
        try {
          const d = await post('/api/settings/runtime', {
            launch_start_time: startSec,
            wallet_address: walletInput.value.trim(),
            sell_tax_pct: Number(sellTaxInput.value || 1),
            token_start_block: Number(tokenStartBlockInput.value || 0),
            spot_pair_address: normalizeAddressOrEmpty(spotPairInput.value),
          });
          if (d?.snapshot) renderSnapshot(d.snapshot);
        } catch {}
      }

      function initLaunchStartInput() {
        const saved = Number(localStorage.getItem(LAUNCH_START_KEY) || 0);
        if (saved > 0) {
          setLaunchInputBySeconds(saved);
        } else {
          setLaunchInputBySeconds(0);
          localStorage.setItem(LAUNCH_START_KEY, '0');
        }
      }

      function startOfLocalDay(d) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
      }

      function sameLocalDay(a, b) {
        return a.getFullYear() === b.getFullYear()
          && a.getMonth() === b.getMonth()
          && a.getDate() === b.getDate();
      }

      function buildDateOptions() {
        const now = new Date();
        const today = startOfLocalDay(now);
        const list = [];
        for (let i = 0; i < 7; i += 1) {
          const d = new Date(today);
          d.setDate(today.getDate() - i);
          let label = `${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
          if (i === 0) label = '今天';
          if (i === 1) label = '昨天';
          list.push({ date: d, label });
        }
        return list;
      }

      function renderWheel(wheelEl, options, labelFn) {
        const items = options.map((opt, idx) => `<div class="wheel-item" data-idx="${idx}">${labelFn(opt)}</div>`).join('');
        wheelEl.innerHTML = `<div class="wheel-track">${items}</div>`;
      }

      function markWheelSelected(wheelEl, idx) {
        wheelEl.querySelectorAll('.wheel-item').forEach((el, i) => {
          el.classList.toggle('active', i === idx);
        });
      }

      function scrollWheelToIndex(wheelEl, idx, smooth = false) {
        wheelEl.scrollTo({
          top: idx * WHEEL_ITEM_HEIGHT,
          behavior: smooth ? 'smooth' : 'auto',
        });
        markWheelSelected(wheelEl, idx);
      }

      function getPickerSelectedDate() {
        const dateObj = pickerState.dateOptions[pickerState.selectedDateIndex]?.date || startOfLocalDay(new Date());
        const h = pickerState.hourOptions[pickerState.selectedHourIndex] || 0;
        const m = pickerState.minuteOptions[pickerState.selectedMinuteIndex] || 0;
        const s = Number.isFinite(launchStartSec) && launchStartSec > 0 ? (launchStartSec % 60) : 0;
        return new Date(
          dateObj.getFullYear(),
          dateObj.getMonth(),
          dateObj.getDate(),
          h,
          m,
          s,
          0
        );
      }

      function updatePickerPreview() {
        launchSheetValue.textContent = formatLocalDisplayFromSeconds(Math.floor(getPickerSelectedDate().getTime() / 1000));
      }

      function bindWheel(wheelEl, key, length) {
        wheelEl.addEventListener('click', (ev) => {
          const item = ev.target?.closest?.('.wheel-item');
          if (!item) return;
          const idx = clamp(Number(item.getAttribute('data-idx') || 0), 0, length - 1);
          if (key === 'date') pickerState.selectedDateIndex = idx;
          if (key === 'hour') pickerState.selectedHourIndex = idx;
          if (key === 'minute') pickerState.selectedMinuteIndex = idx;
          scrollWheelToIndex(wheelEl, idx, true);
          updatePickerPreview();
        });

        wheelEl.addEventListener('scroll', () => {
          clearTimeout(wheelTimers[key]);
          const top = wheelEl.scrollTop;
          const idx = clamp(Math.round(top / WHEEL_ITEM_HEIGHT), 0, length - 1);
          const prevTop = Number(wheelLastTop[key] || 0);
          const delta = Math.abs(top - prevTop);
          wheelLastTop[key] = top;
          markWheelSelected(wheelEl, idx);
          wheelTimers[key] = setTimeout(() => {
            if (key === 'date') pickerState.selectedDateIndex = idx;
            if (key === 'hour') pickerState.selectedHourIndex = idx;
            if (key === 'minute') pickerState.selectedMinuteIndex = idx;
            scrollWheelToIndex(wheelEl, idx, delta > 8);
            updatePickerPreview();
          }, WHEEL_SNAP_DELAY);
        }, { passive: true });
      }

      function stepWheelBy(key, delta) {
        if (key === 'date') {
          pickerState.selectedDateIndex = clamp(pickerState.selectedDateIndex + delta, 0, pickerState.dateOptions.length - 1);
          scrollWheelToIndex(wheelDate, pickerState.selectedDateIndex, true);
        } else if (key === 'hour') {
          pickerState.selectedHourIndex = (pickerState.selectedHourIndex + delta + pickerState.hourOptions.length) % pickerState.hourOptions.length;
          scrollWheelToIndex(wheelHour, pickerState.selectedHourIndex, true);
        } else if (key === 'minute') {
          pickerState.selectedMinuteIndex = (pickerState.selectedMinuteIndex + delta + pickerState.minuteOptions.length) % pickerState.minuteOptions.length;
          scrollWheelToIndex(wheelMinute, pickerState.selectedMinuteIndex, true);
        }
        updatePickerPreview();
      }

      function openLaunchModal() {
        pickerState.dateOptions = buildDateOptions();
        renderWheel(wheelDate, pickerState.dateOptions, (x) => x.label);
        renderWheel(wheelHour, pickerState.hourOptions, (x) => String(x).padStart(2, '0'));
        renderWheel(wheelMinute, pickerState.minuteOptions, (x) => String(x).padStart(2, '0'));

        const baseSec = parseLaunchStartSeconds();
        const base = baseSec > 0 ? new Date(baseSec * 1000) : new Date();
        const foundDateIdx = pickerState.dateOptions.findIndex((x) => sameLocalDay(x.date, base));
        pickerState.selectedDateIndex = foundDateIdx >= 0 ? foundDateIdx : 0;
        pickerState.selectedHourIndex = base.getHours();
        pickerState.selectedMinuteIndex = base.getMinutes();

        scrollWheelToIndex(wheelDate, pickerState.selectedDateIndex, false);
        scrollWheelToIndex(wheelHour, pickerState.selectedHourIndex, false);
        scrollWheelToIndex(wheelMinute, pickerState.selectedMinuteIndex, false);
        updatePickerPreview();

        launchModal.classList.remove('hidden');
      }

      function closeLaunchModal() {
        launchModal.classList.add('hidden');
      }

      function setHint(text, level = '') {
        actionHint.textContent = text;
        actionHint.className = `hint${level ? ` ${level}` : ''}`;
      }

      function setButtonBusy(btn, busy, busyText, idleText) {
        btn.disabled = busy;
        btn.textContent = busy ? busyText : idleText;
        btn.style.opacity = busy ? '0.7' : '1';
        btn.style.cursor = busy ? 'not-allowed' : 'pointer';
      }

      function normalizeWalletList(rawText) {
        const lines = String(rawText || '').split(/\r?\n/).map((x) => x.trim()).filter(Boolean);
        const map = new Map();
        for (const line of lines) {
          if (/^0x[a-fA-F0-9]{40}$/.test(line)) map.set(line.toLowerCase(), line);
        }
        return Array.from(map.keys());
      }

      function syncWalletLabelMap() {
        const next = {};
        for (const addr of myWallets) next[addr] = String(walletLabels?.[addr] || '');
        walletLabels = next;
      }

      function getWalletLabel(addr) {
        const v = String(walletLabels?.[addr] || '').trim();
        return v || '';
      }

      function renderMyWalletTags() {
        myWalletTags.innerHTML = myWallets.map((addr) => `
          <span class="wallet-tag">
            <span class="mono">${shortAddr(addr)}</span>
            <input class="wallet-label-input" data-label-wallet="${addr}" type="text" maxlength="24" placeholder="${t('wallet_name_placeholder')}" value="${getWalletLabel(addr).replace(/"/g, '&quot;')}" />
            <button data-del-wallet="${addr}" type="button">x</button>
          </span>
        `).join('');
      }

      async function applyMyWalletsRuntime(push = true) {
        syncWalletLabelMap();
        renderMyWalletTags();
        localStorage.setItem(LS_MY_WALLETS_KEY, JSON.stringify(myWallets));
        localStorage.setItem(LS_MY_WALLETS_LABELS_KEY, JSON.stringify(walletLabels || {}));
        localStorage.setItem(LS_MY_FROM_BLOCK_KEY, String(Number(myWalletFromBlockInput.value || 0)));
        localStorage.setItem(LS_TOKEN_START_BLOCK_KEY, String(Number(tokenStartBlockInput.value || 0)));
        localStorage.setItem(LS_SPOT_PAIR_KEY, normalizeAddressOrEmpty(spotPairInput.value));
        if (!push) return;
        try {
          await post('/api/settings/runtime', {
            launch_start_time: parseLaunchStartSeconds(),
            wallet_address: walletInput.value.trim(),
            sell_tax_pct: Number(sellTaxInput.value || 1),
            myWallets: myWallets,
            my_wallet_from_block: Number(myWalletFromBlockInput.value || 0),
            token_start_block: Number(tokenStartBlockInput.value || 0),
            spot_pair_address: normalizeAddressOrEmpty(spotPairInput.value),
          });
          setHint(t('wallets_updated', { count: myWallets.length }), 'ok');
        } catch (e) {
          setHint(t('wallets_update_failed', { msg: e.message || String(e) }), 'err');
        }
      }

      function shortAddr(v) {
        if (!v) return '-';
        return `${v.slice(0, 6)}...${v.slice(-4)}`;
      }

      function fmt(n) {
        const v = Number(n || 0);
        const sign = v < 0 ? '-' : '';
        const x = Math.abs(v);
        const pick = (d) => (x >= 100 ? d.toFixed(1) : x >= 10 ? d.toFixed(2) : d.toFixed(3));
        if (x >= 1e12) return `${sign}${pick(x / 1e12)}T`;
        if (x >= 1e9) return `${sign}${pick(x / 1e9)}B`;
        if (x >= 1e6) return `${sign}${pick(x / 1e6)}M`;
        if (x >= 1e3) return `${sign}${pick(x / 1e3)}K`;
        if (x >= 1) return `${sign}${x.toFixed(2)}`;
        return `${sign}${x.toFixed(4)}`;
      }

      function clampPrecision(v, fallback, max = 12) {
        const n = Number(v);
        if (!Number.isFinite(n)) return fallback;
        const i = Math.floor(n);
        return Math.max(0, Math.min(max, i));
      }

      function fmtFixed(n, digits = 8) {
        const v = Number(n);
        if (!Number.isFinite(v)) return '-';
        return v.toFixed(clampPrecision(digits, 8, 18));
      }

      function isHexAddress(v) {
        return /^0x[a-fA-F0-9]{40}$/.test(String(v || '').trim());
      }

      function normalizeAddressOrEmpty(v) {
        const s = String(v || '').trim();
        return isHexAddress(s) ? s : '';
      }

      function normalizeExplorerOptions(raw) {
        const src = raw || {};
        const next = {
          address: String(src.address || '').trim(),
          contractaddress: String(src.contractaddress || '').trim(),
          chainid: String(src.chainid || EXPLORER_DEFAULTS.chainid).trim(),
          startblock: String(src.startblock || EXPLORER_DEFAULTS.startblock).trim(),
          endblock: String(src.endblock || EXPLORER_DEFAULTS.endblock).trim(),
          page: String(src.page || EXPLORER_DEFAULTS.page).trim(),
          offset: String(src.offset || EXPLORER_DEFAULTS.offset).trim(),
          sort: String(src.sort || EXPLORER_DEFAULTS.sort).trim().toLowerCase(),
        };
        if (next.sort !== 'asc' && next.sort !== 'desc') next.sort = EXPLORER_DEFAULTS.sort;
        return next;
      }

      function setExplorerStatus(text, level = '') {
        if (!explorerStatusText) return;
        const color = level === 'err'
          ? '#ffb5c2'
          : level === 'ok'
            ? '#bdeecf'
            : level === 'warn'
              ? '#ffd89d'
              : '#9fc2df';
        explorerStatusText.style.color = color;
        explorerStatusText.textContent = text;
      }

      function applyExplorerOptions(opts, resetAddressAndContract = false) {
        if (!explorerAddressInput) return;
        const value = normalizeExplorerOptions(opts);
        const wallet = String(walletInput?.value || '').trim();
        const token = String(tokenInput?.value || '').trim();
        const fallbackAddress = isHexAddress(wallet) ? wallet : '';
        const fallbackContract = isHexAddress(token) ? token : '';
        if (resetAddressAndContract) {
          explorerAddressInput.value = fallbackAddress;
          explorerContractInput.value = fallbackContract;
        } else {
          explorerAddressInput.value = value.address || fallbackAddress;
          explorerContractInput.value = value.contractaddress || fallbackContract;
        }
        explorerChainIdInput.value = value.chainid;
        explorerStartBlockInput.value = value.startblock;
        explorerEndBlockInput.value = value.endblock;
        explorerPageInput.value = value.page;
        explorerOffsetInput.value = value.offset;
        explorerSortInput.value = value.sort;
      }

      function readExplorerOptions() {
        return normalizeExplorerOptions({
          address: explorerAddressInput?.value,
          contractaddress: explorerContractInput?.value,
          chainid: explorerChainIdInput?.value,
          startblock: explorerStartBlockInput?.value,
          endblock: explorerEndBlockInput?.value,
          page: explorerPageInput?.value,
          offset: explorerOffsetInput?.value,
          sort: explorerSortInput?.value,
        });
      }

      function saveExplorerOptions(opts) {
        localStorage.setItem(LS_EXPLORER_OPTS_KEY, JSON.stringify(normalizeExplorerOptions(opts)));
      }

      function renderExplorerRows(rows) {
        if (!explorerTxBody) return;
        const list = Array.isArray(rows) ? rows : [];
        explorerTxBody.innerHTML = list.map((r) => {
          const ts = Number(r.timeStamp || 0);
          const tm = ts > 0 ? new Date(ts * 1000).toLocaleString() : '-';
          const hash = String(r.hash || '');
          const from = String(r.from || '');
          const to = String(r.to || '');
          const tokenSymbol = String(r.tokenSymbol || '-');
          const tokenDecimal = Number(r.tokenDecimal || 18);
          const valueRaw = Number(r.value || 0);
          const value = Number.isFinite(valueRaw) ? valueRaw / (10 ** Math.min(30, Math.max(0, tokenDecimal))) : 0;
          return `
            <tr>
              <td>${tm}</td>
              <td class="mono" title="${hash}">${shortAddr(hash)}</td>
              <td>${tokenSymbol}</td>
              <td class="mono" title="${from}">${shortAddr(from)}</td>
              <td class="mono" title="${to}">${shortAddr(to)}</td>
              <td>${fmt(value)}</td>
            </tr>
          `;
        }).join('');
      }

      async function queryExplorerTokentx() {
        const opts = readExplorerOptions();
        if (!isHexAddress(opts.address)) {
          setExplorerStatus('address is required and must be 0x...', 'err');
          return;
        }
        if (opts.contractaddress && !isHexAddress(opts.contractaddress)) {
          setExplorerStatus('contractaddress must be 0x... or empty', 'err');
          return;
        }

        saveExplorerOptions(opts);
        setExplorerStatus('querying...', 'warn');
        explorerQueryBtn.disabled = true;

        const url = new URL(apiUrl('/api/explorer/tokentx'), window.location.origin);
        url.searchParams.set('address', opts.address);
        if (opts.contractaddress) url.searchParams.set('contractaddress', opts.contractaddress);
        url.searchParams.set('chainid', opts.chainid);
        url.searchParams.set('startblock', opts.startblock);
        url.searchParams.set('endblock', opts.endblock);
        url.searchParams.set('page', opts.page);
        url.searchParams.set('offset', opts.offset);
        url.searchParams.set('sort', opts.sort);

        try {
          const r = await fetch(url.toString(), { cache: 'no-store' });
          const d = await r.json();
          if (!r.ok || !d?.ok) {
            const msg = d?.error || d?.upstream?.message || 'query failed';
            throw new Error(msg);
          }
          const result = d?.upstream?.result;
          const rows = Array.isArray(result) ? result : [];
          renderExplorerRows(rows);
          if (Array.isArray(result)) {
            setExplorerStatus(`ok, rows=${rows.length}`, 'ok');
          } else {
            const detail = String(result || d?.upstream?.message || 'upstream returned non-array result');
            setExplorerStatus(`no rows, upstream=${detail}`, 'warn');
          }
        } catch (err) {
          setExplorerStatus(String(err?.message || err), 'err');
        } finally {
          explorerQueryBtn.disabled = false;
        }
      }

      function setModeBtn(mode) {
        $('modeToken').classList.toggle('active', mode === 'token_received');
        $('modeVirtual').classList.toggle('active', mode === 'virtual_spent');
      }

      function renderBars(series) {
        const d = (series || []).slice(-10);
        const max = Math.max(1, ...d.map((x) => Number(x.value || 0)));
        bars.innerHTML = d.map((x) => {
          const h = Math.max(4, Math.round((Number(x.value || 0) / max) * 64));
          return `<div class="bar" style="height:${h}px" title="${fmt(x.value)}"></div>`;
        }).join('');
      }

      function renderCurve(curves) {
        const emv = curves?.emvSeries || [];
        const rmv = curves?.rmvSeries || [];
        const n = Math.max(emv.length, rmv.length);
        if (!n) {
          curveSvg.innerHTML = '';
          return;
        }

        const emvVals = emv.map((x) => Number(x.value || 0));
        const rmvVals = rmv.map((x) => Number(x.value || 0));
        const all = [...emvVals, ...rmvVals].filter((x) => Number.isFinite(x));
        const max = Math.max(1, ...all);
        const min = Math.min(0, ...all);
        const h = 220;

        const px = (i) => (i / Math.max(1, n - 1)) * 980 + 10;
        const py = (v) => {
          const ratio = (v - min) / Math.max(1e-9, max - min);
          return h - ratio * 200 + 10;
        };

        const emvPts = emvVals.map((v, i) => `${px(i)},${py(v)}`).join(' ');
        const rmvPts = rmvVals.map((v, i) => `${px(i)},${py(v)}`).join(' ');

        curveSvg.innerHTML = `
          <polyline points="${emvPts}" fill="none" stroke="#67c4ff" stroke-width="3" />
          <polyline points="${rmvPts}" fill="none" stroke="#f8b24f" stroke-width="2.5" stroke-dasharray="5 3" />
          <text x="12" y="18" fill="#9fc2df" font-size="12">max ${fmt(max)}</text>
          <text x="12" y="232" fill="#9fc2df" font-size="12">min ${fmt(min)}</text>
        `;
      }

      function renderHolders(snapshot) {
        const rows = (snapshot.holder_stats || []).slice().sort((a, b) => Number(b.balance || 0) - Number(a.balance || 0)).slice(0, 120);
        holderBody.innerHTML = rows.map((r) => {
          const delta = Number(r.delta_5m_token || 0);
          const cls = delta >= 0 ? 'good' : 'bad';
          return `
            <tr>
              <td class="mono" title="${r.address}">${shortAddr(r.address)}</td>
              <td>${fmt(r.balance)}</td>
              <td>${fmt(r.cumulative_in)}</td>
              <td>${fmt(r.cumulative_out)}</td>
              <td>${Number(r.share_pct || 0).toFixed(2)}%</td>
              <td class="${cls}">${fmt(delta)}</td>
              <td>${fmt(r.cost_per_token)}</td>
              <td>${fmt(r.breakeven_mcap)}</td>
            </tr>
          `;
        }).join('');
      }

      function renderProtocolMonitor(payload) {
        const p = payload || {};
        const s = p.summary || {};
        const addresses = p.addresses || [];
        const flows = p.specialFlows || [];
        protocol1mPill.textContent = `Net 1m: ${fmt(s.net1mV || 0)} V (in ${fmt(s.net1mInV || 0)} / out ${fmt(s.net1mOutV || 0)})`;
        protocol5mPill.textContent = `Net 5m: ${fmt(s.net5mV || 0)} V (in ${fmt(s.net5mInV || 0)} / out ${fmt(s.net5mOutV || 0)})`;
        protocolExecPill.textContent = `Executor 5m: ${Number(s.executor5m || 0)}`;
        sellWallBalancePill.textContent = `Sell Wall Balance: ${fmt(s.sellWallBalanceT || 0)} T`;
        launchPoolBalancePill.textContent = `LaunchPool Balance: ${fmt(s.launchPoolBalanceT || 0)} T`;
        protocolPotentialText.textContent = `Potential: ${Number(s.potential || 0)}`;
        protocolAlertText.textContent = `Alert(${String(s.alert?.level || 'none')}): ${String(s.alert?.message || 'No special alert')}`;
        protocolAlertText.style.color = s.alert?.level === 'critical' ? '#ffb5c2' : s.alert?.level === 'warn' ? '#ffd99f' : '#9fc2df';

        const renderAddrRows = (rows) => rows.map((r) => {
          const cls = Number(r.net1mV || 0) >= 0 ? 'good' : 'bad';
          return `
            <tr>
              <td class="mono" title="${r.address || ''}">${shortAddr(r.address || '')}</td>
              <td>${r.type || '-'}</td>
              <td class="${cls}" title="${Number(r.net1mV || 0)}">${fmt(r.net1mV || 0)}</td>
              <td title="${Number(r.net5mV || 0)}">${fmt(r.net5mV || 0)}</td>
              <td title="${Number(r.net5mT || 0)}">${fmt(r.net5mT || 0)}</td>
              <td>${Number(r.interactions5m || 0)}</td>
            </tr>
          `;
        }).join('');

        protocolBody.innerHTML = renderAddrRows(addresses);
        protocolAddressesEmpty.classList.toggle('hidden', addresses.length > 0);

        specialBody.innerHTML = flows.map((r) => {
          const c = Number(r.v5m || 0) >= 0 ? 'good' : 'bad';
          return `
            <tr>
              <td>${r.label || '-'}</td>
              <td>${r.category || '-'}</td>
              <td class="${c}" title="${Number(r.v5m || 0)}">${fmt(r.v5m || 0)}</td>
              <td title="${Number(r.v1h || 0)}">${fmt(r.v1h || 0)}</td>
              <td title="${Number(r.cumV || 0)}">${fmt(r.cumV || 0)}</td>
              <td title="${Number(r.t5m || 0)}">${fmt(r.t5m || 0)}</td>
              <td title="${Number(r.cumT || 0)}">${fmt(r.cumT || 0)}</td>
            </tr>
          `;
        }).join('');
        specialFlowsEmpty.classList.toggle('hidden', flows.length > 0);
      }

      function renderRealtimePriceAndTrades(snapshot) {
        if (strictChainModeBtn) {
          strictChainModeBtn.textContent = `Strict Chain: ${strictChainMode ? 'ON' : 'OFF'}`;
          strictChainModeBtn.classList.toggle('active', strictChainMode);
        }
        const p = snapshot?.price || {};
        const priceDigits = clampPrecision(pricePrecisionInput?.value, 8, 18);
        const mcapDigits = clampPrecision(mcapPrecisionInput?.value, 2, 8);
        const spotPriceVirtual = Number(p.spot_price_virtual ?? p.spot_price ?? 0);
        const spotMcapVirtual = Number(p.spot_mcap_virtual ?? p.spot_mcap ?? 0);
        const spotPriceUsd = Number(p.spot_price_usd || 0);
        const spotMcapUsd = Number(p.spot_mcap_usd || 0);
        spotPricePill.textContent = `Spot Price /virtual: ${fmtFixed(spotPriceVirtual, priceDigits)}`;
        spotMcapPill.textContent = `Spot MCAP /virtual: ${fmtFixed(spotMcapVirtual, mcapDigits)}`;
        spotPriceUsdPill.textContent = `Spot Price /usd: ${fmtFixed(spotPriceUsd, priceDigits)}`;
        spotMcapUsdPill.textContent = `Spot MCAP /usd: ${fmtFixed(spotMcapUsd, mcapDigits)}`;

        const pairAddr = String(p.pair_address || '');
        const pairTag = pairAddr ? shortAddr(pairAddr) : '-';
        const pairMode = p.pair_auto_discovered ? 'auto' : (pairAddr ? 'manual' : 'n/a');
        const usdPerVirtual = Number(p.usd_per_virtual || 0);
        const usdRateText = Number.isFinite(usdPerVirtual) && usdPerVirtual > 0 ? fmtFixed(usdPerVirtual, priceDigits) : '-';
        const strictText = strictChainMode ? `strict=true | rows=${Number((snapshot?.recent_transfers_raw || []).length || 0)}` : null;
        const streamText = `source=${String(p.source || 'inferred')} | window=${Number(p.window_sec || 0)}s | trades=${Number(p.source_trade_count || 0)}`;
        spotMetaText.textContent = `${strictText ? `${strictText} | ` : ''}${streamText} | pair=${pairTag}(${pairMode}) | 1 virtual=${usdRateText} usd`;

        const rows = strictChainMode
          ? (snapshot?.recent_transfers_raw || []).slice(0, 80)
          : (snapshot?.recent_trades || []).slice(0, 80);
        const filtered = rows.filter((r) => {
          if (strictChainMode) return true;
          const side = String(r.side || 'transfer');
          return side === 'buy' || side === 'sell' || side === 'transfer';
        });
        recentTradeBody.innerHTML = filtered.map((r) => {
          const ts = Number(r.timestamp || 0);
          const tm = ts > 0 ? new Date(ts * 1000).toLocaleTimeString() : '-';
          const side = strictChainMode ? 'transfer' : String(r.side || 'transfer');
          const sideClass = side === 'buy' ? 'good' : side === 'sell' ? 'bad' : '';
          const block = Number(r.block_number || 0);
          const logIndex = Number(r.log_index || 0);
          return `
            <tr>
              <td>${tm}</td>
              <td class="mono">${block > 0 ? `${block}/${logIndex}` : '-'}</td>
              <td class="${sideClass}">${side}</td>
              <td class="mono" title="${r.from_address || ''}">${shortAddr(r.from_address || '')}</td>
              <td class="mono" title="${r.to_address || ''}">${shortAddr(r.to_address || '')}</td>
              <td>${fmt(r.amount_token || 0)}</td>
              <td class="mono">${String(r.amount_raw || '-')}</td>
              <td>${strictChainMode ? '-' : fmt(r.price || 0)}</td>
              <td class="mono" title="${r.tx_hash || ''}">${shortAddr(r.tx_hash || '')}</td>
            </tr>
          `;
        }).join('');
      }

      function renderRule(snapshot) {
        const sig = snapshot.signal_state || {};
        const pair = sig.pair || {};
        const v0 = Number(pair.v0 || 0);
        const v1 = Number(pair.v1 || 0);

        ruleState.className = 'rule-state';
        let text = t('rule_wait');
        let desc = t('rule_wait_desc');

        if (sig.passed_now) {
          text = t('rule_trigger');
          desc = t('rule_trigger_desc');
          ruleState.classList.add('s-trigger');
        } else if (v0 > 3000 && v1 > 6000) {
          text = t('rule_second');
          desc = t('rule_second_desc');
          ruleState.classList.add('s-second');
        } else if (v0 > 3000) {
          text = t('rule_first');
          desc = t('rule_first_desc');
          ruleState.classList.add('s-first');
        } else {
          ruleState.classList.add('s-wait');
        }

        if (Date.now() < flashUntil) ruleState.classList.add('blink');
        ruleState.textContent = text;
        ruleDesc.textContent = desc;
        pairNow.textContent = `${t('pair')}: ${fmt(v0)} -> ${fmt(v1)}`;
      }

      function renderSnapshot(snapshot) {
        if (!snapshot) return;
        latest = snapshot;

        tokenPill.textContent = t('token_line', { token: shortAddr(snapshot.token) });
        statusPill.textContent = t('status_line', {
          status: snapshot.running ? t('status_running') : t('status_stopped'),
          block: snapshot.last_processed_block || '-',
        });
        const ingest = snapshot.ingest || {};
        if (!ingest.counterparty_configured) {
          transferPill.textContent = t('transfers_need_virtual');
        } else if (ingest.no_transfers_in_window) {
          transferPill.textContent = t('transfers_none');
        } else if (Number(ingest.log_count || 0) > 0) {
          transferPill.textContent = t('transfers_logs', { logs: Number(ingest.log_count || 0), tx: Number(ingest.tx_count || 0) });
        } else {
          transferPill.textContent = t('transfers_waiting');
        }
        setModeBtn(snapshot.metric_mode);

        const w = snapshot.windows || {};
        kpi1.textContent = fmt(w.near_1m);
        kpi2.textContent = `${fmt(w.near_2m_sequence?.[0]?.value || 0)} -> ${fmt(w.near_2m_sequence?.[1]?.value || 0)}`;
        kpi5.textContent = fmt(w.near_5m);
        kpiCd.textContent = snapshot.signal_state?.cooling_down
          ? new Date(Number(snapshot.signal_state.cooldown_until || 0) * 1000).toLocaleTimeString()
          : t('cd_ready');

        taxNow.textContent = t('tax_now', { tax: Number(snapshot.tax?.buy_tax_pct || 1).toFixed(0) });
        kpiRmv.textContent = fmt(snapshot.my_wallet?.breakeven_mcap || 0);
        kpiCost.textContent = fmt(snapshot.my_wallet?.cost_per_token || 0);

        renderRule(snapshot);
        renderBars(snapshot.minute_series || []);
        renderCurve(snapshot.curves || {});
        renderHolders(snapshot);
        if (!latestProtocol && snapshot?.token) fetchProtocolMonitor(snapshot.token).catch(() => {});
        renderRealtimePriceAndTrades(snapshot);
        renderMyWalletStats(snapshot.my_wallets || {});
      }

      function renderMyWalletStats(data) {
        if (!myWalletTotalBody || !myWalletBody || !myWalletStatusChip) return;
        const st = data?.status || {};
        const state = String(st.state || 'idle');
        const stateText = state === 'running'
          ? t('wallet_state_running')
          : state === 'queued'
            ? t('wallet_state_queued')
            : state === 'done'
              ? t('wallet_state_done')
              : state === 'error'
                ? t('wallet_state_error')
                : t('wallet_state_idle');
        myWalletStatusChip.className = `status-chip ${state}`;
        myWalletStatusChip.textContent = stateText;
        myWalletStatusChip.title = st.last_error
          ? `Error: ${st.last_error}`
          : (st.last_at ? `Last: ${new Date(st.last_at * 1000).toLocaleTimeString()} | Reason: ${st.last_reason || '-'}` : t('wallet_state_idle'));

        const totalStat = data?.total || {};
        myWalletTotalBody.innerHTML = `
          <tr>
            <td>${t('wallet_total')} (${(data?.addresses || []).length})</td>
            <td>${fmt(totalStat.balance || 0)}</td>
            <td>${fmt(totalStat.spent_virtual_sum || 0)}</td>
            <td>${fmt(totalStat.received_token_sum || 0)}</td>
            <td>${fmt(totalStat.cost_per_token || 0)}</td>
            <td>${fmt(totalStat.effective_cost_per_token || 0)}</td>
            <td>${fmt(totalStat.breakeven_mcap || 0)}</td>
            <td>-</td>
          </tr>
        `;
        const rows = data?.rows || [];
        myWalletBody.innerHTML = rows.map((r) => `
          <tr>
            <td class="mono">
              ${getWalletLabel(r.address) ? `<span class="wallet-name">${getWalletLabel(r.address)}</span>` : ''}
              ${shortAddr(r.address)}
              <button class="copy-btn" data-copy="${r.address}" type="button">${t('wallet_copy')}</button>
            </td>
            <td>${fmt(r.balance)}</td>
            <td>${fmt(r.spent_virtual_sum)}</td>
            <td>${fmt(r.received_token_sum)}</td>
            <td>${fmt(r.cost_per_token)}</td>
            <td>${fmt(r.effective_cost_per_token)}</td>
            <td>${fmt(r.breakeven_mcap)}</td>
            <td>${r.last_active_time ? new Date(r.last_active_time * 1000).toLocaleTimeString() : '-'}</td>
          </tr>
        `).join('');
      }

      async function post(url, body, timeoutMs = 15000) {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const r = await fetch(apiUrl(url), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body || {}),
            signal: controller.signal,
          });
          let d = null;
          try { d = await r.json(); } catch { d = {}; }
          if (!r.ok) throw new Error(d.error || 'request failed');
          return d;
        } finally {
          clearTimeout(timer);
        }
      }

      async function refreshStatusOnce() {
        const d = await fetch(apiUrl('/api/status'), { cache: 'no-store' }).then((r) => r.json());
        if (d?.snapshot) renderSnapshot(d.snapshot);
        return d;
      }

      let lastProtocolToken = '';
      async function fetchProtocolMonitor(token) {
        const tkn = String(token || '').trim().toLowerCase();
        if (!/^0x[a-f0-9]{40}$/.test(tkn)) return null;
        lastProtocolToken = tkn;
        const d = await fetch(apiUrl(`/api/protocol-monitor?token=${tkn}`), { cache: 'no-store' }).then((r) => r.json());
        if (d?.ok) {
          latestProtocol = {
            ...d,
            summary: { ...(d.summary || {}) },
            specialFlows: Array.isArray(d.specialFlows) ? [...d.specialFlows] : [],
            addresses: Array.isArray(d.addresses) ? [...d.addresses] : [],
            potentialAddresses: Array.isArray(d.potentialAddresses) ? [...d.potentialAddresses] : [],
          };
          renderProtocolMonitor(latestProtocol);
          return d;
        }
        return null;
      }

      startBtn.addEventListener('click', async () => {
        if (startBusy) return;
        try {
          const token = tokenInput.value.trim();
          if (!/^0x[a-fA-F0-9]{40}$/.test(token)) {
            setHint(t('start_invalid_token'), 'err');
            return;
          }
          startBusy = true;
          setButtonBusy(startBtn, true, t('start_busy'), t('start_track'));
          setHint(t('start_scanning'), 'warn');

          const payload = {
            token_address: token,
            launch_start_time: parseLaunchStartSeconds(),
            wallet_address: walletInput.value.trim(),
            sell_tax_pct: Number(sellTaxInput.value || 1),
            myWallets: myWallets,
            my_wallet_from_block: Number(myWalletFromBlockInput.value || 0),
            token_start_block: Number(tokenStartBlockInput.value || 0),
            spot_pair_address: normalizeAddressOrEmpty(spotPairInput.value),
          };
          const d = await post('/api/track/start', payload, 30000);
          renderSnapshot(d.snapshot);
          localStorage.setItem(LS_TOKEN_KEY, token);
          localStorage.setItem(LS_WALLET_KEY, walletInput.value.trim());
          setHint(t('start_ok'), 'ok');
        } catch (e) {
          const msg = String(e?.message || e || '');
          if (msg.toLowerCase().includes('abort')) {
            try {
              const st = await refreshStatusOnce();
              if (st?.status?.running) {
                setHint(t('start_abort_running'), 'warn');
              } else {
                setHint(t('start_abort_failed'), 'err');
              }
            } catch {
              setHint(t('start_abort_check_failed'), 'err');
            }
          } else {
            setHint(t('start_failed', { msg }), 'err');
          }
        } finally {
          startBusy = false;
          setButtonBusy(startBtn, false, t('start_busy'), t('start_track'));
        }
      });

      stopBtn.addEventListener('click', async () => {
        if (stopBusy) return;
        try {
          stopBusy = true;
          setButtonBusy(stopBtn, true, t('stop_busy'), t('stop_track'));
          setHint(t('stop_wait'), 'warn');
          await post('/api/track/stop', {}, 15000);
          const st = await fetch(apiUrl('/api/status')).then((r) => r.json());
          if (st?.snapshot) renderSnapshot(st.snapshot);
          statusPill.textContent = t('status_line', { status: t('status_stopped'), block: '-' });
          transferPill.textContent = 'Transfers: -';
          setHint(t('stop_ok'), 'ok');
        } catch (e) {
          const msg = String(e?.message || e || '');
          if (msg.toLowerCase().includes('abort')) {
            try {
              const st = await refreshStatusOnce();
              if (!st?.status?.running) setHint(t('stop_abort_done'), 'warn');
              else setHint(t('stop_abort_running'), 'err');
            } catch {
              setHint(t('stop_abort_check_failed'), 'err');
            }
          } else {
            setHint(t('stop_failed', { msg }), 'err');
          }
        } finally {
          stopBusy = false;
          setButtonBusy(stopBtn, false, t('stop_busy'), t('stop_track'));
        }
      });

      document.querySelectorAll('[data-mode]').forEach((b) => {
        b.addEventListener('click', async () => {
          const mode = b.getAttribute('data-mode');
          await post('/api/settings/mode', { metric_mode: mode });
        });
      });

      explorerQueryBtn?.addEventListener('click', async () => {
        await queryExplorerTokentx();
      });

      explorerResetBtn?.addEventListener('click', () => {
        applyExplorerOptions(EXPLORER_DEFAULTS, true);
        saveExplorerOptions(readExplorerOptions());
        renderExplorerRows([]);
        setExplorerStatus('reset done');
      });

      strictChainModeBtn?.addEventListener('click', () => {
        strictChainMode = !strictChainMode;
        localStorage.setItem(LS_STRICT_CHAIN_MODE_KEY, strictChainMode ? '1' : '0');
        if (latest) renderRealtimePriceAndTrades(latest);
      });

      [pricePrecisionInput, mcapPrecisionInput].forEach((el) => {
        el?.addEventListener('input', () => {
          const priceDigits = clampPrecision(pricePrecisionInput?.value, 8, 18);
          const mcapDigits = clampPrecision(mcapPrecisionInput?.value, 2, 8);
          if (pricePrecisionInput) pricePrecisionInput.value = String(priceDigits);
          if (mcapPrecisionInput) mcapPrecisionInput.value = String(mcapDigits);
          localStorage.setItem(LS_PRICE_PRECISION_KEY, String(priceDigits));
          localStorage.setItem(LS_MCAP_PRECISION_KEY, String(mcapDigits));
          if (latest) renderRealtimePriceAndTrades(latest);
        });
      });

      [walletInput, sellTaxInput, myWalletFromBlockInput, tokenStartBlockInput, spotPairInput].forEach((el) => {
        el.addEventListener('change', async () => {
          try {
            await post('/api/settings/runtime', {
              launch_start_time: parseLaunchStartSeconds(),
              wallet_address: walletInput.value.trim(),
              sell_tax_pct: Number(sellTaxInput.value || 1),
              myWallets: myWallets,
              my_wallet_from_block: Number(myWalletFromBlockInput.value || 0),
              token_start_block: Number(tokenStartBlockInput.value || 0),
              spot_pair_address: normalizeAddressOrEmpty(spotPairInput.value),
            });
            setHint(t('runtime_updated'), 'ok');
          } catch {}
        });
      });

      myWalletApplyBtn.addEventListener('click', () => {
        const incoming = normalizeWalletList(myWalletsInput.value);
        if (!incoming.length) {
          setHint(t('wallets_invalid'), 'err');
          return;
        }
        const before = new Set(myWallets);
        for (const addr of incoming) before.add(addr);
        const next = Array.from(before);
        const added = next.length - myWallets.length;
        myWallets = next;
        myWalletsInput.value = '';
        applyMyWalletsRuntime(true);
        setHint(
          added > 0 ? t('wallets_added', { count: added, total: myWallets.length }) : t('wallets_exists'),
          added > 0 ? 'ok' : 'warn'
        );
      });

      myWalletClearBtn.addEventListener('click', () => {
        myWallets = [];
        walletLabels = {};
        myWalletsInput.value = '';
        renderMyWalletTags();
        applyMyWalletsRuntime(true);
      });

      myWalletTags?.addEventListener('click', (ev) => {
        const btn = ev.target?.closest?.('[data-del-wallet]');
        if (!btn) return;
        const addr = btn.getAttribute('data-del-wallet');
        myWallets = myWallets.filter((x) => x !== addr);
        delete walletLabels[addr];
        renderMyWalletTags();
        applyMyWalletsRuntime(true);
      });

      myWalletTags?.addEventListener('input', (ev) => {
        const input = ev.target?.closest?.('[data-label-wallet]');
        if (!input) return;
        const addr = input.getAttribute('data-label-wallet');
        walletLabels[addr] = String(input.value || '').trim();
        localStorage.setItem(LS_MY_WALLETS_LABELS_KEY, JSON.stringify(walletLabels || {}));
      });

      myWalletBody?.addEventListener('click', async (ev) => {
        const btn = ev.target?.closest?.('[data-copy]');
        if (!btn) return;
        const addr = btn.getAttribute('data-copy');
        try {
          await navigator.clipboard.writeText(addr);
          setHint(t('wallet_copy_ok', { addr: shortAddr(addr) }), 'ok');
        } catch {}
      });

      launchInput.addEventListener('change', () => {
        const ms = launchInput.value ? new Date(launchInput.value).getTime() : NaN;
        if (Number.isFinite(ms) && ms > 0) {
          launchStartSec = Math.floor(ms / 1000);
          launchDisplayBtn.textContent = formatLocalDisplayFromSeconds(launchStartSec);
        }
        applyLaunchStartChange(true);
      });

      launchDisplayBtn.addEventListener('click', () => {
        openLaunchModal();
      });

      setNowBtn.addEventListener('click', () => {
        const nowSec = Math.floor(Date.now() / 1000);
        setLaunchInputBySeconds(nowSec);
        applyLaunchStartChange(true);
        setHint(t('set_now_ok'), 'ok');
      });

      launchBackdrop.addEventListener('click', () => closeLaunchModal());
      launchCloseBtn.addEventListener('click', () => closeLaunchModal());
      launchCancelBtn.addEventListener('click', () => closeLaunchModal());
      launchConfirmBtn.addEventListener('click', () => {
        const sec = Math.floor(getPickerSelectedDate().getTime() / 1000);
        setLaunchInputBySeconds(sec);
        closeLaunchModal();
        applyLaunchStartChange(true);
      });
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && !launchModal.classList.contains('hidden')) {
          closeLaunchModal();
        }
      });

      bindWheel(wheelDate, 'date', 7);
      bindWheel(wheelHour, 'hour', 24);
      bindWheel(wheelMinute, 'minute', pickerState.minuteOptions.length);
      document.querySelectorAll('[data-wheel-step]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const raw = String(btn.getAttribute('data-wheel-step') || '');
          const [key, stepText] = raw.split(':');
          const delta = Number(stepText || 0);
          if (!key || !Number.isFinite(delta) || delta === 0) return;
          stepWheelBy(key, delta);
        });
      });

      function connectEvents() {
        if (eventSource) {
          try { eventSource.close(); } catch {}
          eventSource = null;
        }
        eventSource = new EventSource(apiUrl('/api/events'));
        eventSource.addEventListener('connected', () => {
          console.log('SSE connected');
          setHint(t('sse_connected'), 'ok');
        });
        eventSource.addEventListener('update', (ev) => {
          const p = JSON.parse(ev.data);
          renderSnapshot(p.snapshot);
        });
        eventSource.addEventListener('signal', (ev) => {
          const p = JSON.parse(ev.data);
          flashUntil = Date.now() + 10000;
          renderSnapshot(p.snapshot);
        });
        eventSource.addEventListener('protocol_update', (ev) => {
          const p = JSON.parse(ev.data);
          console.log('protocol_update received', p);
          latestProtocol = {
            ...p,
            summary: { ...(p.summary || {}) },
            specialFlows: Array.isArray(p.specialFlows) ? [...p.specialFlows] : [],
            addresses: Array.isArray(p.addresses) ? [...p.addresses] : [],
            potentialAddresses: Array.isArray(p.potentialAddresses) ? [...p.potentialAddresses] : [],
          };
          renderProtocolMonitor(latestProtocol);
        });
        eventSource.onerror = () => {
          statusPill.textContent = t('status_line', { status: t('status_disconnected'), block: '-' });
          transferPill.textContent = t('transfers_disconnected');
          setHint(t('sse_disconnected'), 'warn');
          if (lastProtocolToken) fetchProtocolMonitor(lastProtocolToken).catch(() => {});
          try { eventSource.close(); } catch {}
          eventSource = null;
          clearTimeout(sseRetryTimer);
          sseRetryTimer = setTimeout(connectEvents, 2500);
        };
      }

      if (currentLang !== 'en' && currentLang !== 'zh') currentLang = 'zh';
      if (langZhBtn) langZhBtn.addEventListener('click', () => setLanguage('zh'));
      if (langEnBtn) langEnBtn.addEventListener('click', () => setLanguage('en'));
      setLanguage(currentLang);

      initLaunchStartInput();
      applyLaunchStartChange(true);
      const savedToken = localStorage.getItem(LS_TOKEN_KEY);
      const savedWallet = localStorage.getItem(LS_WALLET_KEY);
      const savedMyWallets = localStorage.getItem(LS_MY_WALLETS_KEY);
      const savedWalletLabels = localStorage.getItem(LS_MY_WALLETS_LABELS_KEY);
      const savedFromBlock = localStorage.getItem(LS_MY_FROM_BLOCK_KEY);
      const savedTokenStartBlock = localStorage.getItem(LS_TOKEN_START_BLOCK_KEY);
      const savedSpotPair = localStorage.getItem(LS_SPOT_PAIR_KEY);
      const savedPricePrecision = localStorage.getItem(LS_PRICE_PRECISION_KEY);
      const savedMcapPrecision = localStorage.getItem(LS_MCAP_PRECISION_KEY);
      if (savedToken) tokenInput.value = savedToken;
      if (savedWallet) walletInput.value = savedWallet;
      if (savedFromBlock) myWalletFromBlockInput.value = savedFromBlock;
      if (savedTokenStartBlock) tokenStartBlockInput.value = savedTokenStartBlock;
      if (savedSpotPair) spotPairInput.value = savedSpotPair;
      if (pricePrecisionInput) pricePrecisionInput.value = String(clampPrecision(savedPricePrecision, 8, 18));
      if (mcapPrecisionInput) mcapPrecisionInput.value = String(clampPrecision(savedMcapPrecision, 2, 8));
      if (savedMyWallets) {
        try {
          myWallets = JSON.parse(savedMyWallets) || [];
        } catch {
          myWallets = [];
        }
      } else {
        myWallets = [];
      }
      if (savedWalletLabels) {
        try {
          walletLabels = JSON.parse(savedWalletLabels) || {};
        } catch {
          walletLabels = {};
        }
      } else {
        walletLabels = {};
      }
      syncWalletLabelMap();
      myWalletsInput.value = '';
      renderMyWalletTags();
      applyMyWalletsRuntime(false);
      const explorerSavedRaw = localStorage.getItem(LS_EXPLORER_OPTS_KEY);
      let explorerSaved = EXPLORER_DEFAULTS;
      if (explorerSavedRaw) {
        try { explorerSaved = normalizeExplorerOptions(JSON.parse(explorerSavedRaw)); } catch {}
      }
      applyExplorerOptions(explorerSaved, false);
      setExplorerStatus('ready');
      connectEvents();

      fetch(apiUrl('/api/status')).then((r) => r.json()).then((d) => {
        renderSnapshot(d.snapshot);
        if (d?.snapshot?.token) fetchProtocolMonitor(d.snapshot.token).catch(() => {});
      }).catch(() => {
        setHint(t('init_status_failed'), 'err');
      });

      window.addEventListener('beforeunload', () => {
        if (eventSource) {
          try { eventSource.close(); } catch {}
        }
      });
    </script>
  </body>
</html>
